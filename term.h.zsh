#!/usr/bin/env zsh
[ "${ZSH_VERSION:-}" = "" ] && echo >&2 "Only works with zsh" && exit 1  # Just in case people type "bash term.h.zsh".
setopt err_exit no_unset no_clobber pipefail

# TODO: also look at capalias and infoalias in Caps-ncurses.
#
# https://github.com/benhoyt/goawk can run from within Go; that might actually
# be quite nice for this and removes the dependency on zsh and awk.

src=${1:-~/ncurses}
if [[ ! -d $src ]]; then
	print >&2 "ncurses source not in $src; can't generate term.h.go"
	print >&2 'Usage: term.h.zsh [source-tree]'
	exit 1
fi

main() {
	mkdir -p caps scaps keys
	caps       >|caps/caps.go
	scaps      >|scaps/scaps.go
	caps_table >|caps/table.go
	keys       >|keys/keys.go
	gofmt -w caps/caps.go scaps/scaps.go caps/table.go keys/keys.go
}

funs=$(<<'EOF'
	function ucfirst(s) {
		return toupper(substr(s, 1, 1)) substr(s, 2)
	}

	function camelCase(s) {
		while (i = index(s, "_"))
			s = substr(s, 0, i-1) toupper(substr(s, i+1, 1)) substr(s, i+2)
		return ucfirst(s)
	}
EOF
)

# Print package header.
# pkg pkgname [pkgcomment] [add-version] [import]
pkg() {
	print '// Code generated by term.h.zsh; DO NOT EDIT.\n'
	(( $# > 1 && ${#2:-} > 0 )) && print "// Package $1 $2"
	print "package $1\n"
	(( $# > 2 )) && print $3
	if (( $# < 4 )); then
		print '// CursesVersion is the version of curses this data was generated with, as [implementation]-[version].'
		awk '{printf "const CursesVersion = `ncurses-%s.%s`\n\n", $2, $3 }' $src/VERSION
	fi
	return 0
}

# Generate caps/caps.go
caps() {
	pkg caps 'contains a list of all terminfo capabilities.'
	cat <<-'EOF'
		// Cap represents a capability as listed in a terminfo file.
		type Cap struct {
			Short string // Short terminfo name
			Long  string // Longer variable name from term.h
			Desc  string // Description from terminfo(5)
		}
	EOF

	print "var ("
	awk <$src/include/Caps "$funs $(<<-'EOF'
		/^[^#]/ {
			printf "\t%s = &Cap{`%s`, `%s`, `%s", camelCase($1), $2, $1, $8
			for (i=9; i<=NF; i++)
				printf " %s", $i
			print "`}"
		}
	EOF
	)"

	print '\n// Extentions'
	awk <$src/include/Caps-ncurses "$funs $(<<-'EOF'
		$1 == "used_by" { used_by = $2 }
		$1 == "userdef" {
			# Some entries are listed more than once (xm and RGB).
			# TODO: append the descriptions?
			if (uniq[$2])
				next
			uniq[$2] = 1

			printf "\t%s = &Cap{`%s`, `%s`, `%s", camelCase($2), $2, $1, $5
			for (i=6; i<=NF; i++)
				printf " %s", $i
			printf " (%s)`}\n", used_by
		}
	EOF
	)"
	print ")"
}

# Generage scaps/scaps.go
scaps() {
	pkg scaps 'contains a list of all terminfo capabilities.' 'import "zgo.at/termfo/caps"'

	print "var ("
	awk <$src/include/Caps "$funs $(<<-'EOF'
		/^[^#]/ {
			print "\t" ucfirst($2) " = caps." camelCase($1)
		}
	EOF
	)"

	print '\n// Extentions'
	awk <$src/include/Caps-ncurses "$funs $(<<-'EOF'
		$1 == "used_by" { used_by = $2 }
		$1 == "userdef" {
			if (uniq[$2])
				next
			uniq[$2] = 1
			print "\t" ucfirst($2) " = caps." ucfirst($2)
		}
	EOF
	)"
	print ")"
}

# Generate caps/table.go
caps_table() {
	pkg caps '' '' 'no-version'

	for t in bool num str; do
		tu=${t[1]:u}${t[2,-1]}
		print "var Table${tu}s = []*Cap{"
		awk <$src/include/Caps "$funs ${$(<<-'EOF'
			/^[^#]/ && $3 == "TYPE" {
				print camelCase($1) ","
			}
		EOF
		)//TYPE/$t}"

		print '\n// Extensions'
		awk <$src/include/Caps-ncurses "$funs ${$(<<-'EOF'
			$1 == "userdef" && $3 == "TYPE" {
				print camelCase($2) ","
			}
		EOF
		)//TYPE/$t}"
		print "}\n"
	done
}

# List all key caps.
keys() {
	pkg keys '' 'import "zgo.at/termfo/caps"'

	awk <$src/include/Caps "$funs $(<<-'EOF'
		BEGIN {
			print "// Keys maps caps.Cap to Key constants"
			print "var Keys = map[*caps.Cap]Key{"
			i = -1

			# Obscure keys present on very old devices; most people have heard of
			# neither those devices nor these keys, so there's not much point
			# including them. Can still use the termCaps if you really want to, just
			# don't need a shortcut for them.
			#
			# Some of these are still useful codes to send, but they're just not
			# keys (anymore).
			#
			# Use ./cmd/termfo to print terminals which have a certain capability.
			ignore["Catab"]   = "ClearAllTabs"
			ignore["Ctab"]    = "ClearTab"
			ignore["Dl"]      = "DeleteLine"
			ignore["Eic"]     = "Eic"                 # Sent by rmir or smir in insert mode
			ignore["Eol"]     = "ClearToEOL"          # \E[2K
			ignore["Eos"]     = "ClearToEndOfScreen"  # \E[0J
			ignore["Il"]      = "InsertLine"
			ignore["Sr"]      = "ScrollBackward"      # \E[1;2A, or Shift+Up; don't need an entry for this.
			ignore["Sf"]      = "ScrollForward"       # \E[1;2B, or Shift+Down
			ignore["Clear"]   = "ClearScreen"         # \E[2J
			ignore["F0"]      = "F0"
			ignore["Ll"]      = "LowerLeft"           # "Home down"
			ignore["Stab"]    = "SetTab"
			ignore["A1"]      = "KeypadUpperLeft"
			ignore["A3"]      = "KeypadUpperRight"
			ignore["B2"]      = "KeypadCenter"
			ignore["C1"]      = "KeypadLowerLeft"
			ignore["C3"]      = "KeypadLowerRight"
			ignore["Beg"]     = "Begin"
			ignore["Cancel"]  = "Cancel"
			ignore["Close"]   = "Close"
			ignore["Command"] = "Command"             # Not the macOS Command modifier.
			ignore["Copy"]    = "Copy"
			ignore["Create"]  = "Create"
			ignore["Exit"]    = "Exit"
			ignore["Find"]    = "Find"
			ignore["Help"]    = "Help"
			ignore["Mark"]    = "Mark"
			ignore["Message"] = "Message"
			ignore["Move"]    = "Move"
			ignore["KeyNext"] = "x"
			ignore["KeyOpen"] = "x"
			ignore["KeyOptions"] = "x"
			ignore["KeyPrevious"] = "x"
			ignore["KeyPrint"] = "x"
			ignore["KeyRedo"] = "x"
			ignore["KeyReference"] = "x"
			ignore["KeyRefresh"] = "x"
			ignore["KeyReplace"] = "x"
			ignore["KeyRestart"] = "x"
			ignore["KeyResume"] = "x"
			ignore["KeySave"] = "x"
			ignore["KeySuspend"] = "x"
			ignore["KeyUndo"] = "x"
			ignore["KeySbeg"] = "x"
			ignore["KeyScancel"] = "x"
			ignore["KeyScommand"] = "x"
			ignore["KeyScopy"] = "x"
			ignore["KeyScreate"] = "x"
			ignore["KeySdl"] = "x"
			ignore["KeySelect"] = "x"

			#ignore["KeySdc"] = "x"   # Shift+Delete
			#ignore["KeySend"] = "x"  # Shift end
			#ignore["Enter"]   = ""

			# Rename some things for clarity.
			rename["Ic"]    = "Insert"     # \E[2~
			rename["Dc"]    = "Delete"     # \E[3~
			rename["Ppage"] = "PageUp"     # \E[5~
			rename["Npage"] = "PageDown"   # \E[6~
			rename["Btab"]  = "BackTab"    # \E[Z (Shift+Tab)
		}

		/^[^#]/ && $3 == "str" {
			i++
		}

		$5 ~ /^KEY_/ {
			name = toupper(substr($1, 5, 1)) substr($1, 6)
			if (ignore[name] != "")
				next
			if (match(name, /^F([2-9][0-9]|1[3-9])/))  # Who has 64 fucntion keys?!
				next
			if (rename[name] != "")
				name = rename[name]
			allkeys[name] = ""
			printf "\tcaps.TableStrs[%d]: %s,\n", i, name
		}

		END {
			print "}\n"

			print "// List of all key sequences we know about. This excludes most obscure ones not"
			print "// present on modern devices."
			print "const ("
			print "// Special key used to signal errors."
			print "UnknownSequence Key = iota + (1 << 32)\n"
			for (k in allkeys) # TODO: weird order?
				print k
			print ")"

			print "// Names of named key constants."
			print "var keyNames = map[Key]string{"
			for (k in allkeys)
				printf "\t%s: `%s`,\n", k, k
			print "}\n"
		}
	EOF
	)"
}

main
