//go:build ignore
// +build ignore

package main

import (
	"fmt"
	"os"
	"strings"
)

// This is a little bit of an educated guess. I'm not sure what defaults these
// use.
var commonTerms = []string{
	"alacritty",
	"ansi", "pcansi",
	"cygwin",
	"eterm", "eterm-color",
	"gnome", "gnome-256color", "vte", "vte-2018", "vte-256color", "vte-direct",
	"vscode", "vscode-direct",
	"konsole", "konsole-256color",
	"kterm",
	"linux",
	"rxvt", "rxvt-256color", "rxvt-88color", "rxvt-unicode", "rxvt-unicode-256color",
	"screen", "screen-256color",
	"st", "st-256color",
	"termite",
	"tmux", "tmux-256color",
	"vt100", "vt102", "vt220", "vt320", "vt400", "vt420",
	"xfce",
	"xterm", "xterm-88color", "xterm-256color",
	"xterm-kitty",
}

// TODO: make output more stable; lots of map usage here.
// TODO: we can avoid a lot of duplication.
//
// TODO: change to:
//
// func init() {
// 	termfo.Loaders = append(termfo.Loaders, func(t string) *termfo.Terminfo {
// 		switch t {
// 		case "foo":
// 			extMap := ""
// 			return &termfo.Terminfo{}
//
// 		case "bar":
// 			// ...
// 		}
// 	})
// }
func build(pkg string, terms ...string) {
	for i, t := range terms {
		if t == "%common" {
			terms = append(append(terms[:i], terms[i+1:]...), commonTerms...)
			break
		}
	}
	noDup := make(map[string]struct{})
	for _, t := range terms {
		noDup[t] = struct{}{}
	}

	b := new(strings.Builder)
	b.Grow(10_000)
	b.WriteString("// Code generated by termfo; DO NOT EDIT.\n\n/* Command to generate:\n\n")
	fmt.Fprintf(b, "  termfo %s \\\n    ", pkg)
	b.WriteString(strings.Join(os.Args[3:], " \\\n    "))
	fmt.Fprintf(b, "\n*/\n\npackage %s\n\nimport \"zgo.at/termfo\"\n\n", pkg)

	// Extended caps are created first; we want them to be the same pointer
	// in Bools and Extended.
	fmt.Fprintf(b, "func init() {\n\textMap := map[string][]*terminfo.Cap{\n")
	extMap := make(map[string]map[string]int)
	for t := range noDup {
		ti, err := termfo.New(t)
		if err != nil {
			fatalf("could not load terminfo for %q; make sure it's present on "+
				"your system (you may need to install an additional package", t)
		}

		extMap[t] = make(map[string]int)
		fmt.Fprintf(b, "\t\t%#v: {\n", t)
		for i, e := range ti.Extended {
			fmt.Fprintf(b, "\t\t\t%#v,\n", e)
			extMap[t][e.Short] = i
			i++
		}
		fmt.Fprintf(b, "\t\t},\n")
	}

	fmt.Fprintf(b, "\t}\n\n\ttermfo.Builtins(map[string]*termfo.Terminfo{\n")
	for t := range noDup {
		ti, err := termfo.New(t)
		if err != nil {
			fatalf("could not load terminfo for %q; make sure it's present on "+
				"your system (you may need to install an additional package", t)
		}

		ext := ""
		for _, e := range ti.Extended {
			ext += fmt.Sprintf("\t\t\t\textMap[%#v][%d],\n", t, extMap[t][e.Short])
		}
		bools := ""
		for c := range ti.Bools {
			if e, ok := extMap[t][c.Short]; ok {
				bools += fmt.Sprintf("\t\t\t\textMap[%#v][%d]: struct{}{},\n", t, e)
				continue
			}
			for i, b := range termfo.CapBools {
				if c.Short == b.Short {
					bools += fmt.Sprintf("\t\t\t\ttermfo.CapBools[%d]: struct{}{},\n", i)
					break
				}
			}
		}
		nums := ""
		for c, v := range ti.Numbers {
			if e, ok := extMap[t][c.Short]; ok {
				nums += fmt.Sprintf("\t\t\t\textMap[%#v][%d]: %d,\n", t, e, v)
				continue
			}
			for i, b := range termfo.CapNums {
				if c.Short == b.Short {
					nums += fmt.Sprintf("\t\t\t\ttermfo.CapNums[%d]: %d,\n", i, v)
					break
				}
			}
		}
		strs := ""
		for c, v := range ti.Strings {
			if e, ok := extMap[t][c.Short]; ok {
				strs += fmt.Sprintf("\t\t\t\textMap[%#v][%d]: %#v,\n", t, e, v)
				continue
			}
			for i, b := range termfo.CapStrs {
				if c.Short == b.Short {
					strs += fmt.Sprintf("\t\t\t\ttermfo.CapStrs[%d]: %#v,\n", i, v)
					break
				}
			}
		}

		fmt.Fprintf(b, "\t\t%#v: &termfo.Terminfo{", ti.Name)
		fmt.Fprintf(b, `
			Name:    %#[1]v,
			Desc:    %#[2]v,
			Aliases: %#[3]v,
			IntSize: %[4]d,
			Bools:   map[*termfo.Cap]struct{}{
%[5]s
			},
			Numbers: map[*termfo.Cap]int32{
%[6]s
			},
			Strings: map[*termfo.Cap]string{
%[7]s
			},
			Extended: []*termfo.Cap{
%[8]s
			},
		},`, ti.Name, ti.Desc, ti.Aliases, ti.IntSize, bools, nums, strs, ext)
		b.WriteRune('\n')
	}

	fmt.Fprintf(b, "\t})\n}\n")

	fmt.Println(b)
}
